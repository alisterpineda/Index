/**
 * Generated by orval v7.14.0 🍺
 * Do not edit manually.
 * JasperDocs.WebApi | v1
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AccessTokenResponse,
  ForgotPasswordRequest,
  HttpValidationProblemDetails,
  InfoRequest,
  InfoResponse,
  LoginRequest,
  MapIdentityApiConfirmEmailParams,
  PostLoginParams,
  RefreshRequest,
  RegisterRequest,
  ResendConfirmationEmailRequest,
  ResetPasswordRequest,
  TwoFactorRequest,
  TwoFactorResponse
} from '../api.schemas';

import { customAxiosInstance } from '../../axios-instance';




export const postRegister = (
    registerRequest: RegisterRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerRequest, signal
    },
      );
    }
  


export const getPostRegisterMutationOptions = <TError = HttpValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRegister>>, TError,{data: RegisterRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postRegister>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['postRegister'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRegister>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  postRegister(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof postRegister>>>
    export type PostRegisterMutationBody = RegisterRequest
    export type PostRegisterMutationError = HttpValidationProblemDetails

    export const usePostRegister = <TError = HttpValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRegister>>, TError,{data: RegisterRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postRegister>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getPostRegisterMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const postLogin = (
    loginRequest: LoginRequest,
    params?: PostLoginParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AccessTokenResponse>(
      {url: `/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest,
        params, signal
    },
      );
    }
  


export const getPostLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postLogin>>, TError,{data: LoginRequest;params?: PostLoginParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postLogin>>, TError,{data: LoginRequest;params?: PostLoginParams}, TContext> => {

const mutationKey = ['postLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postLogin>>, {data: LoginRequest;params?: PostLoginParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postLogin(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postLogin>>>
    export type PostLoginMutationBody = LoginRequest
    export type PostLoginMutationError = unknown

    export const usePostLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postLogin>>, TError,{data: LoginRequest;params?: PostLoginParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postLogin>>,
        TError,
        {data: LoginRequest;params?: PostLoginParams},
        TContext
      > => {

      const mutationOptions = getPostLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const postRefresh = (
    refreshRequest: RefreshRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AccessTokenResponse>(
      {url: `/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshRequest, signal
    },
      );
    }
  


export const getPostRefreshMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRefresh>>, TError,{data: RefreshRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postRefresh>>, TError,{data: RefreshRequest}, TContext> => {

const mutationKey = ['postRefresh'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRefresh>>, {data: RefreshRequest}> = (props) => {
          const {data} = props ?? {};

          return  postRefresh(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof postRefresh>>>
    export type PostRefreshMutationBody = RefreshRequest
    export type PostRefreshMutationError = unknown

    export const usePostRefresh = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRefresh>>, TError,{data: RefreshRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postRefresh>>,
        TError,
        {data: RefreshRequest},
        TContext
      > => {

      const mutationOptions = getPostRefreshMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const mapIdentityApiConfirmEmail = (
    params: MapIdentityApiConfirmEmailParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/confirmEmail`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getMapIdentityApiConfirmEmailQueryKey = (params?: MapIdentityApiConfirmEmailParams,) => {
    return [
    `/confirmEmail`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getMapIdentityApiConfirmEmailQueryOptions = <TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = unknown>(params: MapIdentityApiConfirmEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMapIdentityApiConfirmEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>> = ({ signal }) => mapIdentityApiConfirmEmail(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MapIdentityApiConfirmEmailQueryResult = NonNullable<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>>
export type MapIdentityApiConfirmEmailQueryError = unknown


export function useMapIdentityApiConfirmEmail<TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = unknown>(
 params: MapIdentityApiConfirmEmailParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>,
          TError,
          Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMapIdentityApiConfirmEmail<TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = unknown>(
 params: MapIdentityApiConfirmEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>,
          TError,
          Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMapIdentityApiConfirmEmail<TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = unknown>(
 params: MapIdentityApiConfirmEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useMapIdentityApiConfirmEmail<TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = unknown>(
 params: MapIdentityApiConfirmEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMapIdentityApiConfirmEmailQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postResendConfirmationEmail = (
    resendConfirmationEmailRequest: ResendConfirmationEmailRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/resendConfirmationEmail`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resendConfirmationEmailRequest, signal
    },
      );
    }
  


export const getPostResendConfirmationEmailMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResendConfirmationEmail>>, TError,{data: ResendConfirmationEmailRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postResendConfirmationEmail>>, TError,{data: ResendConfirmationEmailRequest}, TContext> => {

const mutationKey = ['postResendConfirmationEmail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postResendConfirmationEmail>>, {data: ResendConfirmationEmailRequest}> = (props) => {
          const {data} = props ?? {};

          return  postResendConfirmationEmail(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostResendConfirmationEmailMutationResult = NonNullable<Awaited<ReturnType<typeof postResendConfirmationEmail>>>
    export type PostResendConfirmationEmailMutationBody = ResendConfirmationEmailRequest
    export type PostResendConfirmationEmailMutationError = unknown

    export const usePostResendConfirmationEmail = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResendConfirmationEmail>>, TError,{data: ResendConfirmationEmailRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postResendConfirmationEmail>>,
        TError,
        {data: ResendConfirmationEmailRequest},
        TContext
      > => {

      const mutationOptions = getPostResendConfirmationEmailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const postForgotPassword = (
    forgotPasswordRequest: ForgotPasswordRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/forgotPassword`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: forgotPasswordRequest, signal
    },
      );
    }
  


export const getPostForgotPasswordMutationOptions = <TError = HttpValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postForgotPassword>>, TError,{data: ForgotPasswordRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postForgotPassword>>, TError,{data: ForgotPasswordRequest}, TContext> => {

const mutationKey = ['postForgotPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postForgotPassword>>, {data: ForgotPasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  postForgotPassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof postForgotPassword>>>
    export type PostForgotPasswordMutationBody = ForgotPasswordRequest
    export type PostForgotPasswordMutationError = HttpValidationProblemDetails

    export const usePostForgotPassword = <TError = HttpValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postForgotPassword>>, TError,{data: ForgotPasswordRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postForgotPassword>>,
        TError,
        {data: ForgotPasswordRequest},
        TContext
      > => {

      const mutationOptions = getPostForgotPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const postResetPassword = (
    resetPasswordRequest: ResetPasswordRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/resetPassword`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetPasswordRequest, signal
    },
      );
    }
  


export const getPostResetPasswordMutationOptions = <TError = HttpValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResetPassword>>, TError,{data: ResetPasswordRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postResetPassword>>, TError,{data: ResetPasswordRequest}, TContext> => {

const mutationKey = ['postResetPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postResetPassword>>, {data: ResetPasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  postResetPassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof postResetPassword>>>
    export type PostResetPasswordMutationBody = ResetPasswordRequest
    export type PostResetPasswordMutationError = HttpValidationProblemDetails

    export const usePostResetPassword = <TError = HttpValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResetPassword>>, TError,{data: ResetPasswordRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postResetPassword>>,
        TError,
        {data: ResetPasswordRequest},
        TContext
      > => {

      const mutationOptions = getPostResetPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const postManage2fa = (
    twoFactorRequest: TwoFactorRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<TwoFactorResponse>(
      {url: `/manage/2fa`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: twoFactorRequest, signal
    },
      );
    }
  


export const getPostManage2faMutationOptions = <TError = HttpValidationProblemDetails | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManage2fa>>, TError,{data: TwoFactorRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postManage2fa>>, TError,{data: TwoFactorRequest}, TContext> => {

const mutationKey = ['postManage2fa'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postManage2fa>>, {data: TwoFactorRequest}> = (props) => {
          const {data} = props ?? {};

          return  postManage2fa(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostManage2faMutationResult = NonNullable<Awaited<ReturnType<typeof postManage2fa>>>
    export type PostManage2faMutationBody = TwoFactorRequest
    export type PostManage2faMutationError = HttpValidationProblemDetails | void

    export const usePostManage2fa = <TError = HttpValidationProblemDetails | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManage2fa>>, TError,{data: TwoFactorRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postManage2fa>>,
        TError,
        {data: TwoFactorRequest},
        TContext
      > => {

      const mutationOptions = getPostManage2faMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const getManageInfo = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<InfoResponse>(
      {url: `/manage/info`, method: 'GET', signal
    },
      );
    }
  



export const getGetManageInfoQueryKey = () => {
    return [
    `/manage/info`
    ] as const;
    }

    
export const getGetManageInfoQueryOptions = <TData = Awaited<ReturnType<typeof getManageInfo>>, TError = HttpValidationProblemDetails | void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetManageInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getManageInfo>>> = ({ signal }) => getManageInfo(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetManageInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getManageInfo>>>
export type GetManageInfoQueryError = HttpValidationProblemDetails | void


export function useGetManageInfo<TData = Awaited<ReturnType<typeof getManageInfo>>, TError = HttpValidationProblemDetails | void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getManageInfo>>,
          TError,
          Awaited<ReturnType<typeof getManageInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetManageInfo<TData = Awaited<ReturnType<typeof getManageInfo>>, TError = HttpValidationProblemDetails | void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getManageInfo>>,
          TError,
          Awaited<ReturnType<typeof getManageInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetManageInfo<TData = Awaited<ReturnType<typeof getManageInfo>>, TError = HttpValidationProblemDetails | void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetManageInfo<TData = Awaited<ReturnType<typeof getManageInfo>>, TError = HttpValidationProblemDetails | void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetManageInfoQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postManageInfo = (
    infoRequest: InfoRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<InfoResponse>(
      {url: `/manage/info`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: infoRequest, signal
    },
      );
    }
  


export const getPostManageInfoMutationOptions = <TError = HttpValidationProblemDetails | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManageInfo>>, TError,{data: InfoRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postManageInfo>>, TError,{data: InfoRequest}, TContext> => {

const mutationKey = ['postManageInfo'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postManageInfo>>, {data: InfoRequest}> = (props) => {
          const {data} = props ?? {};

          return  postManageInfo(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostManageInfoMutationResult = NonNullable<Awaited<ReturnType<typeof postManageInfo>>>
    export type PostManageInfoMutationBody = InfoRequest
    export type PostManageInfoMutationError = HttpValidationProblemDetails | void

    export const usePostManageInfo = <TError = HttpValidationProblemDetails | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManageInfo>>, TError,{data: InfoRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postManageInfo>>,
        TError,
        {data: InfoRequest},
        TContext
      > => {

      const mutationOptions = getPostManageInfoMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    